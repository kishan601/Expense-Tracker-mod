{"ast":null,"code":"\"use client\";\n\n// src/useQueries.ts\nimport * as React from \"react\";\nimport { QueriesObserver, QueryObserver, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./IsRestoringProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary } from \"./errorBoundaryUtils.js\";\nimport { ensureSuspenseTimers, fetchOptimistic, shouldSuspend, willFetch } from \"./suspense.js\";\nimport { noop } from \"./utils.js\";\nfunction useQueries({\n  queries,\n  ...options\n}, queryClient) {\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedQueries = React.useMemo(() => queries.map(opts => {\n    const defaultedOptions = client.defaultQueryOptions(opts);\n    defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n    return defaultedOptions;\n  }), [queries, client, isRestoring]);\n  defaultedQueries.forEach(query => {\n    ensureSuspenseTimers(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(() => new QueriesObserver(client, defaultedQueries, options));\n  const [optimisticResult, getCombinedResult, trackResult] = observer.getOptimisticResult(defaultedQueries, options.combine);\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(React.useCallback(onStoreChange => shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop, [observer, shouldSubscribe]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    observer.setQueries(defaultedQueries, options);\n  }, [defaultedQueries, options, observer]);\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) => shouldSuspend(defaultedQueries[index], result));\n  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {\n    const opts = defaultedQueries[index];\n    if (opts) {\n      const queryObserver = new QueryObserver(client, opts);\n      if (shouldSuspend(opts, result)) {\n        return fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find((result, index) => {\n    const query = defaultedQueries[index];\n    return query && getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: query.throwOnError,\n      query: client.getQueryCache().get(query.queryHash),\n      suspense: query.suspense\n    });\n  });\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return getCombinedResult(trackResult());\n}\nexport { useQueries };","map":{"version":3,"names":["React","QueriesObserver","QueryObserver","notifyManager","useQueryClient","useIsRestoring","useQueryErrorResetBoundary","ensurePreventErrorBoundaryRetry","getHasError","useClearResetErrorBoundary","ensureSuspenseTimers","fetchOptimistic","shouldSuspend","willFetch","noop","useQueries","queries","options","queryClient","client","isRestoring","errorResetBoundary","defaultedQueries","useMemo","map","opts","defaultedOptions","defaultQueryOptions","_optimisticResults","forEach","query","observer","useState","optimisticResult","getCombinedResult","trackResult","getOptimisticResult","combine","shouldSubscribe","subscribed","useSyncExternalStore","useCallback","onStoreChange","subscribe","batchCalls","getCurrentResult","useEffect","setQueries","shouldAtLeastOneSuspend","some","result","index","suspensePromises","flatMap","queryObserver","length","Promise","all","firstSingleResultWhichShouldThrow","find","throwOnError","getQueryCache","get","queryHash","suspense","error"],"sources":["D:/GitHub/expense-tracker/expense-tracker/node_modules/@tanstack/react-query/build/modern/useQueries.js"],"sourcesContent":["\"use client\";\n\n// src/useQueries.ts\nimport * as React from \"react\";\nimport {\n  QueriesObserver,\n  QueryObserver,\n  notifyManager\n} from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./IsRestoringProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nimport { noop } from \"./utils.js\";\nfunction useQueries({\n  queries,\n  ...options\n}, queryClient) {\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedQueries = React.useMemo(\n    () => queries.map((opts) => {\n      const defaultedOptions = client.defaultQueryOptions(\n        opts\n      );\n      defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n      return defaultedOptions;\n    }),\n    [queries, client, isRestoring]\n  );\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(\n    () => new QueriesObserver(\n      client,\n      defaultedQueries,\n      options\n    )\n  );\n  const [optimisticResult, getCombinedResult, trackResult] = observer.getOptimisticResult(\n    defaultedQueries,\n    options.combine\n  );\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop,\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options\n    );\n  }, [defaultedQueries, options, observer]);\n  const shouldAtLeastOneSuspend = optimisticResult.some(\n    (result, index) => shouldSuspend(defaultedQueries[index], result)\n  );\n  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {\n    const opts = defaultedQueries[index];\n    if (opts) {\n      const queryObserver = new QueryObserver(client, opts);\n      if (shouldSuspend(opts, result)) {\n        return fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index];\n      return query && getHasError({\n        result,\n        errorResetBoundary,\n        throwOnError: query.throwOnError,\n        query: client.getQueryCache().get(query.queryHash),\n        suspense: query.suspense\n      });\n    }\n  );\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return getCombinedResult(trackResult());\n}\nexport {\n  useQueries\n};\n//# sourceMappingURL=useQueries.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}